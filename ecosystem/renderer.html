<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Entity Wireframe</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <link rel="stylesheet" href="/css/style.css">
  <style>
    body {
      margin: 0;
    }
    svg {
      width: 100%;
      height: 100vh;
      background-color: #f2f2f2;
    }
    .node ellipse {
      fill: #fd6c1d;
      stroke: #222;
      stroke-width: 2px;
      cursor: pointer;
    }
    .title-text {
      fill: #fff;
      font-family: sans-serif;
      font-weight: bold;
      pointer-events: none;
    }
    .description-box {
      fill: #f2f2f2;
      stroke: #505050;
      stroke-width: 1px;
    }
    .description-text {
      fill: #505050;
      font-size: 12px;
      font-family: sans-serif;
      pointer-events: none;
    }
    .link {
      stroke: #505050;
      stroke-width: 2px;
    }
  </style>
</head>
<body>
  <button id="menu-toggle" aria-label="Toggle Menu">&#9776;</button>
  <header onclick="window.location.href='/'" style="cursor:pointer">
    <img id=logo src="/logos/logo.png">
    <h1 onclick="window.locaiton.href='/'" id="headertitle">Airbrx</h1>
    <p id="headerblurb">Unlocking Business Value from Your Data</p>
  </header>
  <div class="container">
      <nav class="menu" id="menu">

      </nav>
      <main class="content" style="padding:40px">
        <div class="article">
          <p>this is a very simple wireframe rendering tool to show the interconnections between different systems in a data ecosystem.</p>
        </div>
<svg></svg>

<script>
  const svg = d3.select("svg");
  const width = window.innerWidth;
  const height = window.innerHeight;
  const maxTextWidth = 140;

  // Wrap SVG text into tspans
  function wrapText(text, width) {
    text.each(function () {
      const text = d3.select(this);
      const words = text.text().split(/\s+/).reverse();
      let word, line = [], lineNumber = 0;
      const y = text.attr("y") || 0;
      let tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y);

      while (word = words.pop()) {
        line.push(word);
        tspan.text(line.join(" "));
        if (tspan.node().getComputedTextLength() > width) {
          line.pop();
          tspan.text(line.join(" "));
          line = [word];
          tspan = text.append("tspan").attr("x", 0).attr("y", y).text(word);
        }
      }
    });
  }

  function wrapDescriptionText(text, maxWidth) {
    const words = text.split(/\s+/);
    const lines = [];
    let line = "";

    words.forEach(word => {
      const testLine = line + word + " ";
      const testLength = getTextLength(testLine);
      if (testLength > maxWidth && line.length > 0) {
        lines.push(line.trim());
        line = word + " ";
      } else {
        line = testLine;
      }
    });

    if (line) lines.push(line.trim());
    return lines;
  }

  function getTextLength(text) {
    const temp = svg.append("text")
      .attr("class", "description-text")
      .text(text);
    const length = temp.node().getComputedTextLength();
    temp.remove();
    return length;
  }

  function limit(value, min, max) {
    return Math.max(min, Math.min(max, value));
  }

  d3.json("ecosystem.json").then(data => {
    const nodes = data.map(d => ({ ...d }));
    const nodeById = Object.fromEntries(nodes.map(d => [d.entityId, d]));

    const links = [];
    nodes.forEach(node => {
      node.connectors.forEach(targetId => {
        if (nodeById[targetId]) {
          links.push({ source: node.entityId, target: targetId });
        }
      });
    });

    const simulation = d3.forceSimulation(nodes)
      .force("link", d3.forceLink(links).id(d => d.entityId).distance(200))
      .force("charge", d3.forceManyBody().strength(-500))
      .force("center", d3.forceCenter(width / 2, height / 2))
      .force("collide", d3.forceCollide(100));

    const link = svg.append("g")
      .attr("stroke", "#505050")
      .selectAll("line")
      .data(links)
      .join("line")
      .attr("class", "link");

    const node = svg.append("g")
      .selectAll("g")
      .data(nodes)
      .join("g")
      .attr("class", "node")
      .on("click", function (event, d) {
        // Remove all open descriptions
        d3.selectAll(".description-box").remove();
        d3.selectAll(".description-text").remove();

        const group = d3.select(this);

        const lines = wrapDescriptionText(d.description, maxTextWidth - 20);
        const lineHeight = 16;
        const totalHeight = lines.length * lineHeight;
        const boxWidth = maxTextWidth;

        const yOffset = 45;

        // Description background
        group.append("rect")
          .attr("class", "description-box")
          .attr("x", -boxWidth / 2)
          .attr("y", yOffset)
          .attr("width", boxWidth)
          .attr("height", totalHeight + 10)
          .attr("rx", 6)
          .attr("ry", 6);

        // Description text
        lines.forEach((line, i) => {
          group.append("text")
            .attr("class", "description-text")
            .attr("text-anchor", "middle")
            .attr("x", 0)
            .attr("y", yOffset + 20 + i * lineHeight)
            .text(line);
        });
      });

    node.each(function (d) {
      const group = d3.select(this);

      const tempText = group.append("text")
        .attr("class", "title-text")
        .attr("text-anchor", "middle")
        .text(d.title);

      wrapText(tempText, maxTextWidth);

      const tspans = tempText.selectAll("tspan");
      const lineCount = tspans.size();
      const ry = 20 + (lineCount - 1) * 10;

      // Vertical centering of text
      const lineHeight = 1.2;
      const offset = -((lineCount - 1) / 2) * lineHeight;
      tspans.each(function (_, i) {
        d3.select(this)
          .attr("x", 0)
          .attr("dy", `${i === 0 ? offset : lineHeight}em`);
      });

      group.append("ellipse")
        .lower()
        .attr("rx", maxTextWidth / 2)
        .attr("ry", ry);
    });

    simulation.on("tick", () => {
      link
        .attr("x1", d => limit(d.source.x, 0, width))
        .attr("y1", d => limit(d.source.y, 0, height))
        .attr("x2", d => limit(d.target.x, 0, width))
        .attr("y2", d => limit(d.target.y, 0, height));

      node.attr("transform", d => {
        d.x = limit(d.x, 120, width - 120);
        d.y = limit(d.y, 100, height - 100);
        return `translate(${d.x},${d.y})`;
      });
    });
  });
</script>
</body>
</html>
